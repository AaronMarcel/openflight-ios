//
//  Copyright (C) 2020 Parrot Drones SAS.
//
//    Redistribution and use in source and binary forms, with or without
//    modification, are permitted provided that the following conditions
//    are met:
//    * Redistributions of source code must retain the above copyright
//      notice, this list of conditions and the following disclaimer.
//    * Redistributions in binary form must reproduce the above copyright
//      notice, this list of conditions and the following disclaimer in
//      the documentation and/or other materials provided with the
//      distribution.
//    * Neither the name of the Parrot Company nor the names
//      of its contributors may be used to endorse or promote products
//      derived from this software without specific prior written
//      permission.
//
//    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
//    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
//    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
//    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
//    PARROT COMPANY BE LIABLE FOR ANY DIRECT, INDIRECT,
//    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
//    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
//    OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
//    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
//    OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
//    OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
//    SUCH DAMAGE.

import Foundation

// MARK: - Public Enums
/// Flight Plan execution states.
public enum FlightPlanExecutionState: String, Codable {
    case initialized
    case completed
    case stopped
    case error
}

/// Class used to link a Gutma flight file with a Flight Plan.
public final class FlightPlanExecution: Codable, Equatable {
    // MARK: - Public Properties
    public var flightPlanId: String
    public var flightId: String?
    public var startDate: Date
    public var endDate: Date?
    public var state: FlightPlanExecutionState {
        didSet {
            // Reset recovery id when execution is completed.
            if state == .completed {
                self.flightPlanRecoveryId = nil
                self.latestItemExecuted = nil
                // TODO: remove mavlink file when it will be linked to an execution
            }
        }
    }
    public var settings: [FlightPlanLightSetting]?
    /// Used to resume flight plan execution.
    public var latestItemExecuted: Int?
    /// Property used to get the medias of a flight plan execution.
    public let executionId: String
    /// Property used to get recovery id of the flight plan.
    /// This id is generated by the drone.
    public var flightPlanRecoveryId: String?

    // MARK: - Private Enums
    enum CodingKeys: String, CodingKey {
        case flightPlanId
        case flightId
        case startDate
        case endDate
        case state
        case settings
        case latestItemExecuted
        case executionId
        case flightPlanRecoveryId
    }

    // MARK: - Init
    /// Init.
    ///
    /// - Parameters:
    ///    - executionId: Execution Id
    ///    - flightPlanId: Flight Plan Id
    ///    - flightId: flight Id
    ///    - startDate: start date
    ///    - endDate: end date
    ///    - state: Flight Plan execution state
    ///    - settings: list of Flight Plan settings
    ///    - projectId: project Id
    ///    - latestItemExecuted: latest item executed
    ///    - flightPlanRecoveryId: Flight Plan recovery Id
    init(executionId: String = UUID().uuidString,
         flightPlanId: String,
         flightId: String?,
         startDate: Date,
         endDate: Date? = nil,
         state: FlightPlanExecutionState = .initialized,
         settings: [FlightPlanLightSetting]? = nil,
         projectId: Int64? = nil,
         latestItemExecuted: Int? = nil,
         flightPlanRecoveryId: String?) {
        self.executionId = executionId
        self.flightPlanId = flightPlanId
        self.flightId = flightId
        self.startDate = startDate
        self.endDate = endDate
        self.state = state
        self.settings = settings
        self.latestItemExecuted = latestItemExecuted
        self.flightPlanRecoveryId = flightPlanRecoveryId
    }

    // MARK: - Equatable
    public static func == (lhs: FlightPlanExecution, rhs: FlightPlanExecution) -> Bool {
        return lhs.executionId == rhs.executionId
            && lhs.flightPlanId == rhs.flightPlanId
            && lhs.flightId == rhs.flightId
            && lhs.startDate == rhs.startDate
            && lhs.endDate == rhs.endDate
            && lhs.state == rhs.state
            && lhs.settings == rhs.settings
            && lhs.latestItemExecuted == rhs.latestItemExecuted
            && lhs.flightPlanRecoveryId == rhs.flightPlanRecoveryId
    }
}

// MARK: - Public Properties
public extension FlightPlanExecution {
    /// Returns mavlink url for an execution regarding the flight plan id.
    var mavlinkUrl: URL? {
        // NSTemporaryDirectory will be updated to not store mavlink temporary.
        let urlString = NSTemporaryDirectory() + self.flightPlanId
        return URL(fileURLWithPath: urlString).appendingPathExtension(FlightPlanConstants.mavlinkExtension)
    }
}

// MARK: - Internal Funcs
/// Provides helpers for `FlightPlanExecution`.
extension FlightPlanExecution {
    /// Returns fomatted execution date.
    ///
    /// - Parameters:
    ///     - isShort: result string should be short
    /// - Returns: fomatted execution date or dash if formatting failed.
    func fomattedExecutionDate(isShort: Bool) -> String {
        let fomattedDate = isShort ? self.startDate.shortFormattedString : self.startDate.shortWithTimeFormattedString
        return fomattedDate ?? Style.dash
    }

    /// Saves latest item executed during a flight plan execution.
    ///
    /// - Parameters:
    ///     - latestItemExecuted: flight plan execution last item executed
    func saveLatestItemExecuted(with latestItemExecuted: Int) {
        guard self.latestItemExecuted != latestItemExecuted else { return }

        self.latestItemExecuted = latestItemExecuted
        // Update current execution in database.
        CoreDataManager.shared.saveOrUpdate(execution: self)
    }

    /// Saves execution state.
    ///
    /// - Parameters:
    ///     - state: new flight plan execution state
    func saveExecutionState(with state: FlightPlanExecutionState) {
        guard self.state != state else { return }

        self.state = state
        // Update current execution in database.
        CoreDataManager.shared.saveOrUpdate(execution: self)
    }
}
